#include <iostream>
#include <NTL/ZZ.h>

using namespace std;
using namespace NTL;

string toBinary(ZZ n)
{
    string r;
    while (n != 0){
        r += ( n % 2 == 0 ? "0" : "1" );
        n /= 2;
    }
    return r;
}

ZZ module(ZZ a, ZZ n){
    ZZ r = a-n*(a/n);
    r = r+(r<0)*n;
    return r;
}

void gcdExtended(ZZ a, ZZ b, ZZ& x, ZZ& y) {
    x = ZZ(1), y = ZZ(0);

    ZZ x1(0), y1(1), a1(a), b1(b);
    while (b1 != 0) {
        ZZ q = a1 / b1;
        tie(x, x1) = make_tuple(x1, x - q * x1);
        tie(y, y1) = make_tuple(y1, y - q * y1);
        tie(a1, b1) = make_tuple(b1, a1 - q * b1);
    }
}

ZZ inverse(ZZ a,ZZ n){
    ZZ x,y;
    gcdExtended(a,n,x,y);
    return module(x,n);
}

ZZ fast(ZZ a,ZZ p,ZZ n){
    ZZ t;
    if(p == 0) return ZZ(1);
    if((p&1)==0){
        t = fast(a,p>>1,n);
        return module(t*t,n);
    }
    t = fast(a,(p-1)>>1,n);
    return module(a *module(t*t,n),n);
}

ZZ binary(ZZ b, ZZ e, ZZ m)
{
	ZZ result = (e & 1)==1 ? b : ZZ(1);
	while (e != 0) {
		e >>= 1;
		b = module((b * b), m);
		if ((e & 1)==1)
			result = module((result * b), m);
	}
	return result;
}

void right_to_left_binary(ZZ g , ZZ e ,ZZ m){
    ZZ A(1);
    while(e != 0){
        if((e & 1) == 1) A=module(A*g,m);
        e>>=1;
        g= module(g*g,m);
    }
    cout<<A;
}

void left_to_right_binary(ZZ b, ZZ e, ZZ mod){
    ZZ A(1);
    string bin = toBinary(e);
    for (int i = bin.size(); i != -1; i--){
        A = module(A * A, mod);
        if(bin[i] == '1'){
            A = module(A * b, mod);
        }
    }
    cout<<A;
}

ZZ NaiveExponentiation(ZZ g , ZZ e ,ZZ m){
    ZZ A (1);
    for(int i=0;i<e;i++){
        A = module(A*g,m);
    }
    return A;
}

void TRC(ZZ a , ZZ e,ZZ p, ZZ q){
    //descomponer
    ZZ a1,a2,d1,d2,P,P1,P2,q1,q2,D;
    d1 = module(e,p-1);
    d2 = module(e,q-1);
    a1 = binary(a,d1,p);
    a2 = binary(a,d2,q);
    // calculo de P
    P = p*q;
    P1 = P/p;
    P2 = P/q;
    // q*P=1modp
    q1 = inverse(P1,p);
    q2 = inverse(P2,q);
    // D = a*P*q ..
    D = module(module(a1*P1,P)*q1 + module(a2*P2,P)*q2,P);

    cout<<D;
}

int main()
{

    ZZ base = conv <ZZ> ("32317006071311007300714876688669951960444102669715484032130345427524655138867890893197201411522913463688717960921898019494119559150490921095088152386448283120630877367300996091750197750389652106796057638384067568276792218642619756161838094338476170470581645852036305042887575891541065808607552399123930385521914333389668342420684974786564569494856176035326322058077805659331026192708460314150258592864177116725943603718461857357598351152301645904403697613233287231227125684710820209725157101726931323469678542580656697935045997268352998638215525166389437335543602135433229604645318478604952148193555853611059596230655");
    ZZ expo = conv <ZZ> ("16158503035655503650357438344334975980222051334857742016065172713762327569433945446598600705761456731844358980460949009747059779575245460547544076193224141560315438683650498045875098875194826053398028819192033784138396109321309878080919047169238085235290822926018152521443787945770532904303776199561965192760957166694834171210342487393282284747428088017663161029038902829665513096354230157075129296432088558362971801859230928678799175576150822952201848806616643615613562842355410104862578550863465661734839271290328348967522998634176499319107762583194718667771801067716614802322659239302476074096777926805529798115328");
    ZZ mod = conv <ZZ>  ("27898503035655503650357438344334975980222051334857742016065172713762327569433945446598600705761456731844358980460949009747059779575245460547544076193224141560315438683650498045875098875194826053398028819192033784138396109321309878080919047169238085235290822926018152521443787945770532904303776199561965192760957166694834171210342487393282284747428088017663161029038902829665513096354230157075129296432088558362971801859230928678799175576150822952201848806616643615613562842355410104862578550863465661734839271290328348967522998634176499319107762583194718667771801067716614802322659239302476074096777926805529798115328");
    ZZ p = conv <ZZ> ("756789563789110073007148766886699519604441026697154840321303454275246551388678908931972014115229134636887179609218980194941195591504909210950881523864482831206308773673009960917501977503896521067960576383840675682767922186426197561618380943384761704705816458520363050428875758915");
    ZZ q = conv <ZZ> ("42702763909039039105836668462894536726391591684566203936297164292273475705094288346986021023710775292398371137260160871724928291814572009012871120194484887926811503410279510518111417131952125902277222551546569187868093450936074687422132040739470922338292700733597796095130033164790484424404731910200098199084444714569851851162960355601211");

    //cout<<fast(base, expo, mod);
    //cout<<binary(base, expo, mod);
    //right_to_left_binary(base, expo, mod);
    //left_to_right_binary(base, expo, mod);
    //NaiveExponentiation(base, expo, mod);
    TRC(base, expo, p, q);
}
